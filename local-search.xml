<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【转载】CSEJavaSDK重试和隔离如何判断错误？</title>
    <link href="undefined2019/12/17/java-chassis-circuitbreaker-isolate-counter-logic/"/>
    <url>2019/12/17/java-chassis-circuitbreaker-isolate-counter-logic/</url>
    
    <content type="html"><![CDATA[<p>mark一篇CSEJavaSDK熔断、隔离判断逻辑的帖子，同样适用于ServiceComb-Java-Chassis。</p><p>原文链接： <a href="https://bbs.huaweicloud.com/forum/thread-12790-1-1.html" target="_blank" rel="noopener">https://bbs.huaweicloud.com/forum/thread-12790-1-1.html</a></p><a id="more"></a><h1 id="技术交流-CSE重试和隔离如何判断错误？"><a href="#技术交流-CSE重试和隔离如何判断错误？" class="headerlink" title="[技术交流]CSE重试和隔离如何判断错误？"></a>[技术交流]CSE重试和隔离如何判断错误？</h1><blockquote><p>简单的描述：</p><ol><li><p>网络错误 + 503错误码等情况可以触发重试。</p></li><li><p>网络错误 + 503错误码 + 超时等错误可以触发隔离。</p></li></ol></blockquote><p>细节内容可以参考代码：</p><h2 id="负载均衡模块能力"><a href="#负载均衡模块能力" class="headerlink" title="负载均衡模块能力"></a>负载均衡模块能力</h2><p>LB模块具备请求重试和实例隔离能力。</p><ul><li>请求重试的条件参考<code>org.apache.servicecomb.loadbalance.DefaultRetryExtensionsFactory</code></li><li>实例隔离的条件参考<code>org.apache.servicecomb.loadbalance.LoadbalanceHandler#isFailedResponse</code></li><li>实例隔离状态恢复的逻辑参考<code>org.apache.servicecomb.loadbalance.filter.IsolationDiscoveryFilter#allowVisit</code></li><li>Java-Chassis定期ping机制会在某实例近期没有被调用时定时去检查其状态，该检查如果失败会产生和调用失败一样的错误计数，但是检查成功不会触发实例隔离恢复，相关逻辑在<code>org.apache.servicecomb.loadbalance.ServiceCombLoadBalancerStats#timer</code>的定时任务中。</li></ul><h2 id="熔断隔离模块能力"><a href="#熔断隔离模块能力" class="headerlink" title="熔断隔离模块能力"></a>熔断隔离模块能力</h2><p>CSE还提供了bizkeeper模块，这个模块集成了Hystrix的隔离仓等能力，这个隔离能力是针对微服务或者接口级别的，在实际业务系统中，发挥作用比较少。 这个模块也有判读错误条件：</p><ul><li>consumer: 490异常。 比如网络操作、超时等。 参考<code>org.apache.servicecomb.bizkeeper.ConsumerBizkeeperCommand#isFailedResponse</code></li><li>provider: 590异常。比如业务处理抛出的未知RuntimeException等。 参考<code>org.apache.servicecomb.bizkeeper.ProviderBizkeeperCommand#isFailedResponse</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>软件技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSE</tag>
      
      <tag>microservice</tag>
      
      <tag>ServiceComb-Java-Chassis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用keytool和OpenSSL自行签发TLS证书</title>
    <link href="undefined2019/11/13/CreateTLSCertificateByKeytoolAndOpenssl/"/>
    <url>2019/11/13/CreateTLSCertificateByKeytoolAndOpenssl/</url>
    
    <content type="html"><![CDATA[<p>本文主要说明如何使用JDK自带的keytool和OpenSSL自行签发TLS证书，方便进行本地开发测试。</p><a id="more"></a><h1 id="使用keytool和OpenSSL自行签发TLS证书"><a href="#使用keytool和OpenSSL自行签发TLS证书" class="headerlink" title="使用keytool和OpenSSL自行签发TLS证书"></a>使用keytool和OpenSSL自行签发TLS证书</h1><blockquote><p>本文适用于Java微服务场景下，自行创建CA和签发TLS证书，方便自行开发调试，不适合于生产条件。<br>最终目录结构：</p><pre><code>workdir    // 这是本文的工作目录，可以随意自定义|- ca      // CA证书所在目录（根证书）|- cert    // 服务端/客户端身份证书所在目录|- trust   // 信任证书所在目录</code></pre></blockquote><h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><p>创建一份证书，基本步骤有三步：</p><ol><li><p>创建一份自己的私钥文件</p><p>理论上讲这份私钥文件，必须保密，不能让其他人获取到内容的。</p></li><li><p>生成一份“证书请求文件”</p><p>生成证书请求文件的后缀一般是<code>.csr</code>(Certificate Signing Request)。<br>如果你要购买一份生产环境使用的TLS证书，就需要签一份csr文件发给CA，让他们根据你的csr文件签发证书给你。</p></li><li><p>签发证书</p><p>由于本文创建的证书只是用于开发、测试目的，所以不需要向CA购买证书，而是自行创建CA证书，再用CA证书签发TLS证书。</p></li></ol><p>在创建完TLS证书（身份证书）后，我们还可以使用JDK自带的<code>keytool</code>创建一份信任证书，这样可以让这套证书用于Java服务TLS对端认证的测试场景。</p><hr><p>环境信息：</p><ul><li>OpenJDK 1.8.0_191</li><li>OpenSSL 1.1.0g</li></ul><h2 id="创建CA"><a href="#创建CA" class="headerlink" title="创建CA"></a>创建CA</h2><p>跳转到 ca 目录下。由于是自己当CA签证书，所以要先创建好CA的证书。</p><h3 id="创建CA证书私钥"><a href="#创建CA证书私钥" class="headerlink" title="创建CA证书私钥"></a>创建CA证书私钥</h3><p>命令<code>openssl genrsa -aes128 -out ca.key 4096</code>表示以aes128加密的方式生成一个长度为4096bit的RSA私钥文件。<br><strong>注意</strong>：创建过程中<code>openssl</code>会让你输入私钥文件的密码，进行加密。</p><pre><code class="shell">workdir/ca# openssl genrsa -aes128 -out ca.key 4096Generating RSA private key, 4096 bit long modulus.............................................................................++.....................................++e is 65537 (0x010001)Enter pass phrase for ca.key:Verifying - Enter pass phrase for ca.key:workdir/ca# lltotal 12drwxr-xr-x 2 root root 4096 Nov 12 23:09 ./drwxr-xr-x 3 root root 4096 Nov 12 23:08 ../-rw------- 1 root root 3326 Nov 12 23:09 ca.key</code></pre><p>执行完成后当前目录下应该生成了一份<code>ca.key</code>文件，这份文件是私钥，应该保密存储。</p><h3 id="创建CA证书"><a href="#创建CA证书" class="headerlink" title="创建CA证书"></a>创建CA证书</h3><p>命令<code>openssl req -new -x509 -key ca.key -out ca.crt -days 3650</code> 的含义为，使用CA私钥（<code>-key ca.key</code>），创建一份CA证书（<code>-out ca.crt</code>），有效时间为3650天（<code>-days 3650</code>）。<br><strong>注意</strong>：这一步需要输入CA私钥文件的密码，即上一步创建<code>ca.key</code>文件时设置的密码。</p><pre><code class="shell">workdir/ca# openssl req -new -x509 -key ca.key -out ca.crt -days 3650Enter pass phrase for ca.key:You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &#39;.&#39;, the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:GuangdongLocality Name (eg, city) []:ShenzhenOrganization Name (eg, company) [Internet Widgits Pty Ltd]:xxxOrganizational Unit Name (eg, section) []:xxxCommon Name (e.g. server FQDN or YOUR name) []:xxxEmail Address []:xxx@xxx.xxxworkdir/ca# lltotal 16drwxr-xr-x 2 root root 4096 Nov 12 23:21 ./drwxr-xr-x 3 root root 4096 Nov 12 23:08 ../-rw-r--r-- 1 root root 2069 Nov 12 23:21 ca.crt-rw------- 1 root root 3326 Nov 12 23:09 ca.key</code></pre><p>创建证书过程中需要输入所在地、公司名称，因为本文生成证书的目的只是开发测试，所以这里是随便填写的。执行完成后能够看到一份<code>ca.crt</code>文件。</p><h2 id="签发身份证书"><a href="#签发身份证书" class="headerlink" title="签发身份证书"></a><span id="签发身份证书">签发身份证书</span></h2><p>跳转到 cert 目录下。</p><h3 id="生成私钥"><a href="#生成私钥" class="headerlink" title="生成私钥"></a>生成私钥</h3><p>操作和刚才生成CA私钥一样，不再赘述。</p><pre><code class="shell">workdir/cert# openssl genrsa -aes128 -out server.key 4096Generating RSA private key, 4096 bit long modulus.............................++........................................................................................................................................................................................................................++e is 65537 (0x010001)Enter pass phrase for server.key:Verifying - Enter pass phrase for server.key:workdir/cert# lltotal 12drwxr-xr-x 2 root root 4096 Nov 12 23:32 ./drwxr-xr-x 4 root root 4096 Nov 12 23:31 ../-rw------- 1 root root 3326 Nov 12 23:32 server.key</code></pre><h3 id="创建证书请求文件"><a href="#创建证书请求文件" class="headerlink" title="创建证书请求文件"></a>创建证书请求文件</h3><p>创建证书请求文件需要用到上一步创建的私钥文件（<code>server.key</code>)。<code>A challenge password</code>和<code>An optional company name</code>那里可以直接敲回车跳过不填。</p><pre><code class="shell">workdir/cert# openssl req -new -key server.key -out server.csrEnter pass phrase for server.key:You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &#39;.&#39;, the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:GuangdongLocality Name (eg, city) []:ShenzhenOrganization Name (eg, company) [Internet Widgits Pty Ltd]:xxxOrganizational Unit Name (eg, section) []:xxxCommon Name (e.g. server FQDN or YOUR name) []:xxxEmail Address []:xxx@xxx.xxxPlease enter the following &#39;extra&#39; attributesto be sent with your certificate requestA challenge password []:An optional company name []:workdir/cert# lltotal 16drwxr-xr-x 2 root root 4096 Nov 12 23:42 ./drwxr-xr-x 4 root root 4096 Nov 12 23:31 ../-rw-r--r-- 1 root root 1724 Nov 12 23:42 server.csr-rw------- 1 root root 3326 Nov 12 23:32 server.key</code></pre><p>执行完成后目录下会出现一份<code>server.csr</code>文件。</p><h3 id="签发证书文件"><a href="#签发证书文件" class="headerlink" title="签发证书文件"></a>签发证书文件</h3><p>注意这里执行的命令会指定使用上面创建的CA证书以及CA私钥文件（<code>-CA ../ca/ca.crt -CAkey ../ca/ca.key</code>），有效期为3650天，输出文件为<code>server.crt</code>。</p><pre><code class="shell">workdir/cert# openssl x509 -req -days 3650 -in server.csr -CA ../ca/ca.crt -CAkey ../ca/ca.key -CAcreateserial -out server.crtSignature oksubject=C = CN, ST = Guangdong, L = Shenzhen, O = xxx, OU = xxx, CN = xxx, emailAddress = xxx@xxx.xxxGetting CA Private KeyEnter pass phrase for ../ca/ca.key:workdir/cert# lltotal 24drwxr-xr-x 2 root root 4096 Nov 12 23:49 ./drwxr-xr-x 4 root root 4096 Nov 12 23:31 ../-rw-r--r-- 1 root root 1948 Nov 12 23:49 server.crt-rw-r--r-- 1 root root 1724 Nov 12 23:42 server.csr-rw------- 1 root root 3326 Nov 12 23:32 server.key-rw-r--r-- 1 root root   17 Nov 12 23:49 .srl</code></pre><h3 id="将crt证书转换为PKCS12格式"><a href="#将crt证书转换为PKCS12格式" class="headerlink" title="将crt证书转换为PKCS12格式"></a>将crt证书转换为PKCS12格式</h3><p>上一步其实已经成功创建出身份证书了（就是<code>server.crt</code>），这里把该文件转换成PKCS12格式，方便Java服务使用。<br><strong>注意</strong>：这一步需要输入私钥<code>server.key</code>的密码，导出证书的密码可由读者自行设置。</p><pre><code class="shell">workdir/cert# openssl pkcs12 -export -in server.crt -inkey server.key -out server.p12Enter pass phrase for server.key:Enter Export Password:Verifying - Enter Export Password:workdir/cert# lltotal 32drwxr-xr-x 2 root root 4096 Nov 13 00:09 ./drwxr-xr-x 5 root root 4096 Nov 12 23:52 ../-rw-r--r-- 1 root root 1948 Nov 12 23:49 server.crt-rw-r--r-- 1 root root 1724 Nov 12 23:42 server.csr-rw------- 1 root root 3326 Nov 12 23:32 server.key-rw------- 1 root root 4157 Nov 13 00:09 server.p12-rw-r--r-- 1 root root   17 Nov 12 23:49 .srl</code></pre><h2 id="创建信任证书"><a href="#创建信任证书" class="headerlink" title="创建信任证书"></a>创建信任证书</h2><p>跳转到trust目录。</p><h3 id="创建keystore文件"><a href="#创建keystore文件" class="headerlink" title="创建keystore文件"></a>创建keystore文件</h3><p>使用keytool新建一份 keystore 文件，这个文件会被用作信任证书：</p><pre><code class="shell">workdir/trust# keytool -genkeypair -alias trust -keystore trust.jks -keyalg RSA -sigalg SHA1withRSAEnter keystore password:Re-enter new password:What is your first and last name?  [Unknown]:  xxxWhat is the name of your organizational unit?  [Unknown]:  xxxWhat is the name of your organization?  [Unknown]:  xxxWhat is the name of your City or Locality?  [Unknown]:  ShenzhenWhat is the name of your State or Province?  [Unknown]:  GuangdongWhat is the two-letter country code for this unit?  [Unknown]:  CNIs CN=xxx, OU=xxx, O=xxx, L=Shenzhen, ST=Guangdong, C=CN correct?  [no]:  yes</code></pre><p><strong>注意</strong>：创建过程中<code>keytool</code>会要求你给这份 keystore 文件设置密码。<br>执行成功的话会在trust目录下生成一份 keystore 文件：</p><pre><code>workdir/trust# lltotal 12drwxr-xr-x 2 root root 4096 Nov 12 23:54 ./drwxr-xr-x 5 root root 4096 Nov 12 23:52 ../-rw-r--r-- 1 root root 2557 Nov 12 23:54 trust.jks</code></pre><h3 id="导入CA证书"><a href="#导入CA证书" class="headerlink" title="导入CA证书"></a>导入CA证书</h3><p>将前文创建的CA证书导入到<code>trust.jks</code>文件中，这样，使用此CA证书签发的TLS证书就都被这份 keystore 文件信任了。<br><strong>注意</strong>：导入过程需要输入<code>trust.jks</code>文件的密码，也可以在命令中使用<code>-storepass</code>参数输入密码。</p><pre><code class="shell">workdir/trust# keytool -import -file ../ca/ca.crt -keystore trust.jksEnter keystore password:Owner: EMAILADDRESS=xxx@xxx.xxx, CN=xxx, OU=xxx, O=xxx, L=Shenzhen, ST=Guangdong, C=CNIssuer: EMAILADDRESS=xxx@xxx.xxx, CN=xxx, OU=xxx, O=xxx, L=Shenzhen, ST=Guangdong, C=CNSerial number: d66ebd9ea172d18aValid from: Tue Nov 12 23:21:27 CST 2019 until: Fri Nov 09 23:21:27 CST 2029Certificate fingerprints:         SHA1: A2:19:67:E6:D2:A2:6E:7E:E6:C8:15:2C:CD:F7:48:70:EF:85:03:8D         SHA256: 58:FF:94:50:E4:22:73:A3:8C:77:7D:6E:06:38:D6:98:0D:0D:58:83:44:46:93:CB:4E:56:48:AE:AC:41:63:F0Signature algorithm name: SHA256withRSASubject Public Key Algorithm: 4096-bit RSA keyVersion: 3Extensions:#1: ObjectId: 2.5.29.35 Criticality=falseAuthorityKeyIdentifier [KeyIdentifier [0000: 95 4E 27 2B 65 7C E6 8F   E3 F8 46 7D 09 3B 44 ED  .N&#39;+e.....F..;D.0010: 08 60 94 00                                        .`..]]#2: ObjectId: 2.5.29.19 Criticality=trueBasicConstraints:[  CA:true  PathLen:2147483647]#3: ObjectId: 2.5.29.14 Criticality=falseSubjectKeyIdentifier [KeyIdentifier [0000: 95 4E 27 2B 65 7C E6 8F   E3 F8 46 7D 09 3B 44 ED  .N&#39;+e.....F..;D.0010: 08 60 94 00                                        .`..]]Trust this certificate? [no]:  yesCertificate was added to keystore</code></pre><p>执行成功后，可以运行<code>keytool -list -v -keystore trust.jks</code>命令查看导入的内容。</p><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>至此，证书生成工作就完成了。对于Java服务，可以使用<code>cert</code>目录下的<code>server.p12</code>作为身份证书，<code>trust</code>目录下的<code>trust.jks</code>作为信任证书来启动服务。<br><code>trust.jks</code>信任了签发<code>server.p12</code>的CA证书，所以客户端、服务端程序开启TLS对端认证进行测试时，可以使用同一套证书，<br>也可以重复<a href="#签发身份证书">签发身份证书</a>的步骤签发多套证书。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="如何查看证书"><a href="#如何查看证书" class="headerlink" title="如何查看证书"></a>如何查看证书</h3><ul><li><p>使用keytool查看crt证书：</p><p><code>keytool -printcert -v -file server.crt</code></p></li><li><p>使用keytool查看keystore文件：</p><p><code>keytool -list -v -keystore trust.jks</code></p></li><li><p>使用OpenSSL查看crt证书：</p><p><code>openssl x509 -in server.crt -text -noout</code></p></li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.cnblogs.com/yjmyzz/p/openssl-tutorial.html" target="_blank" rel="noopener">https://www.cnblogs.com/yjmyzz/p/openssl-tutorial.html</a></li><li><a href="https://sites.google.com/site/ddmwsst/create-your-own-certificate-and-ca" target="_blank" rel="noopener">https://sites.google.com/site/ddmwsst/create-your-own-certificate-and-ca</a></li><li><a href="https://blog.csdn.net/defonds/article/details/85098684" target="_blank" rel="noopener">https://blog.csdn.net/defonds/article/details/85098684</a></li><li><a href="https://blog.csdn.net/linvo/article/details/9150607" target="_blank" rel="noopener">https://blog.csdn.net/linvo/article/details/9150607</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>软件技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TLS</tag>
      
      <tag>OpenSSL</tag>
      
      <tag>keytool</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解Java-Chassis契约校验失败导致的微服务实例注册失败问题</title>
    <link href="undefined2019/03/22/WhySchemaInconsistencyCauseServiceInstanceStartUpFailure/"/>
    <url>2019/03/22/WhySchemaInconsistencyCauseServiceInstanceStartUpFailure/</url>
    
    <content type="html"><![CDATA[<p>一篇文章说清楚为什么ServiceComb-Java-Chassis校验服务契约的机制那么严格。</p><a id="more"></a><h1 id="详解Java-Chassis契约校验失败导致的微服务实例注册失败问题"><a href="#详解Java-Chassis契约校验失败导致的微服务实例注册失败问题" class="headerlink" title="详解Java-Chassis契约校验失败导致的微服务实例注册失败问题"></a>详解Java-Chassis契约校验失败导致的微服务实例注册失败问题</h1><p>相信不少同学在使用 CSEJavaSDK / ServiceComb-Java-Chassis 开发微服务的过程中都碰到过修改了服务接口后服务就无法启动的情况。控制台上会打出如下的异常栈：</p><pre><code>Exception in thread &quot;main&quot; java.lang.IllegalStateException: ServiceComb init failed.    at org.apache.servicecomb.core.SCBEngine.init(SCBEngine.java:220)    at org.apache.servicecomb.core.CseApplicationListener.onApplicationEvent(CseApplicationListener.java:81)    at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)    at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)    at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)    at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:393)    at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:347)    at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:883)    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:546)    at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:139)    at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:93)    at org.apache.servicecomb.foundation.common.utils.BeanUtils.init(BeanUtils.java:49)    at org.apache.servicecomb.foundation.common.utils.BeanUtils.init(BeanUtils.java:42)    at microservice.demo.training21days.provider.AppMain.main(AppMain.java:9)Caused by: java.lang.IllegalStateException: The schema(id=[hello]) content held by this instance and the service center is different. You need to increment microservice version before deploying. Or you can configure service_description.environment=development to work in development environment and ignore this error    at org.apache.servicecomb.serviceregistry.task.MicroserviceRegisterTask.compareAndReRegisterSchema(MicroserviceRegisterTask.java:277)    at org.apache.servicecomb.serviceregistry.task.MicroserviceRegisterTask.registerSchema(MicroserviceRegisterTask.java:206)    at org.apache.servicecomb.serviceregistry.task.MicroserviceRegisterTask.registerSchemas(MicroserviceRegisterTask.java:170)    at org.apache.servicecomb.serviceregistry.task.MicroserviceRegisterTask.doRegister(MicroserviceRegisterTask.java:122)    at org.apache.servicecomb.serviceregistry.task.AbstractRegisterTask.doRun(AbstractRegisterTask.java:41)    at org.apache.servicecomb.serviceregistry.task.AbstractTask.run(AbstractTask.java:53)    at org.apache.servicecomb.serviceregistry.task.CompositeTask.run(CompositeTask.java:35)    at org.apache.servicecomb.serviceregistry.task.ServiceCenterTask.init(ServiceCenterTask.java:82)    at org.apache.servicecomb.serviceregistry.registry.AbstractServiceRegistry.run(AbstractServiceRegistry.java:178)    at org.apache.servicecomb.serviceregistry.registry.RemoteServiceRegistry.run(RemoteServiceRegistry.java:86)    at org.apache.servicecomb.serviceregistry.RegistryUtils.run(RegistryUtils.java:70)    at org.apache.servicecomb.core.SCBEngine.doInit(SCBEngine.java:255)    at org.apache.servicecomb.core.SCBEngine.init(SCBEngine.java:209)    ... 13 more</code></pre><p>其实这里抛出的异常已经告诉大家问题的原因和解决方式了。问题原因是这个服务在服务中心里注册的契约内容和这个实例实际持有的契约内容不一致（契约的id也打出来了，这里是<code>&quot;hello&quot;</code>）。至于解决方案，这里给出了两种：</p><ol><li>增加微服务的版本，也就是要修改<code>microservice.yaml</code>配置文件里的<code>service_description.version</code>配置项的值</li><li>将环境更改为开发环境，也就是在<code>microservice.yaml</code>配置文件里加上一个配置 <code>service_description.environment=development</code></li></ol><p>那么这里的两种问题解决方式应该选择哪一种呢，还有其他的解决方式吗？我们还是得先从服务契约本身说起。</p><p>一个 ServiceComb-Java-Chassis 框架的微服务在启动时会扫描它全部的REST接口类，并根据这些接口类生成对应的服务契约，并确保它们随着自己的服务记录一起注册到了服务中心。服务契约不仅仅是一份“接口文档”，同时它也约束着微服务的运行时行为。微服务会根据服务契约来确定如何调用其他服务，以及如何执行参数的序列化、反序列化操作等等。<br>也就是说， ServiceComb-Java-Chassis 的服务契约，不是那种大家开发完新功能后想起来要更新了就去改一下，忘记了或者没时间就不改的“接口说明文档”。它跟服务的接口有着严格的对应关系。<strong>如果契约不一样的话，那么就说明，你的服务，真的，有接口变化</strong>。</p><p>说到接口变化，大家都知道这是一个比较严肃的事情了。通常一个服务的接口都应该是经过设计和评审的，不能轻易改变（跟其他服务联调过的同学对这个应该有体会吧？）。<br>在正式的环境（生产环境）下，服务接口变更发生在什么时候呢？答案是，服务版本变更的时候。抛开那些不按套路出牌的开发团队不谈，一般情况下一个服务版本应该上线哪些功能，提供哪些接口，都是应该有规划和记录的。也就是说，一个服务的每个版本的接口都是确定的，不应该出现一个版本的服务有两套不同的接口的情况。</p><p>到这里，大家知道为什么你会碰到本文开头碰到的问题了吧？<br>原因很明确，就是<strong>你不应该在一个版本的微服务里给出两套不相同的接口</strong>。想想如果你的生产环境里，同一个版本的微服务混进去了一批接口不一样的服务实例（微服务架构下通常都是多实例部署服务的），那么你的系统一会儿可以正常工作，一会儿报各种参数错误、接口不存在之类的问题。这些问题的表象可能会显得很隐晦、随机或者复杂，而你在线上环境里很难排查出来。<br>为了避免将这类问题引入到线上， CSEJavaSDK / ServiceComb-Java-Chassis 采取了严格的服务契约校验策略，确保你的线上的服务一定是接口一致的。</p><p>所以异常里给出的两种解决方案其实也是针对不同的场景的：</p><ol><li>如果你正在开发新版本的服务，接口本来就变来变去的没定下来，那么你可以把你的微服务的环境改为开发环境（<code>service_description.environment=development</code>），此时微服务框架允许你变更你的接口并更新注册到服务中心。</li><li>如果是测试、生产环境，这个时候服务接口应该稳定下来了，服务契约不同通常意味着这应该是一个新版本。那么你应该给你的服务分配一个更新的版本号了。</li></ol><p>顺带一提，开发自测时还有一种问题解决办法，就是直接把服务中心里的旧服务记录删掉，更简单 ; )</p><blockquote><p>删完记得把上游调用它的服务重启一下，consumer端只加载一次provider的服务契约，之后不再动态刷新的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>软件技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>microservice</tag>
      
      <tag>ServiceComb-Java-Chassis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一个Spring ApplicationContext重复加载的问题</title>
    <link href="undefined2018/12/29/TomcatContextDuplicateLoadingProblem/"/>
    <url>2018/12/29/TomcatContextDuplicateLoadingProblem/</url>
    
    <content type="html"><![CDATA[<p>Spring ApplicationContext重复加载可能造成各种奇怪问题，如无法自动注入Spring Bean、Spring Bean重复加载报错等等。仔细观察启动日志通常能从Spring应用上下文加载日志中看出一点端倪。</p><a id="more"></a><h1 id="记录一个Spring-ApplicationContext重复加载的问题"><a href="#记录一个Spring-ApplicationContext重复加载的问题" class="headerlink" title="记录一个Spring ApplicationContext重复加载的问题"></a>记录一个Spring ApplicationContext重复加载的问题</h1><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>有同事开发了一个demo服务，服务包含前端页面和ServiceComb开发的REST后端服务两部分。打成war包部署在Tomcat中，发现这个服务会在服务中心注册两个地址相同的实例。观察日志，发现Spring Context加载了两遍，并且Tomcat的webapps目录下存在一个与war包同名的目录和一个ROOT目录，两个目录中的内容是相同的。</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>Tomcat在启动时会将webapps目录下的war包解压到一个同名目录下，将其作为一个context加载。而在Tomcat的<code>conf/server.xml</code>文件中，又额外定义了一个Context：</p><pre><code class="xml">&lt;Context path=&quot;/&quot; reloadable=&quot;true&quot; docBase=&quot;${war包的名字}&quot;/&gt;</code></pre><p>于是该war包会作为root context 又被加载一次。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>删掉<code>conf/server.xml</code>文件中定义的context，把拷贝到webapps目录下的war包改名为<code>ROOT.war</code>。Tomcat启动时会自动将war包解压作为root context加载。</p>]]></content>
    
    
    <categories>
      
      <category>软件技术</category>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker容器内部署Java微服务的内存限制问题</title>
    <link href="undefined2018/11/24/MemoryConsumingOfJvmInDocker/"/>
    <url>2018/11/24/MemoryConsumingOfJvmInDocker/</url>
    
    <content type="html"><![CDATA[<p>警惕JVM占用内存超过K8S容器内存配额限制，进而导致微服务进程被关闭的问题。</p><a id="more"></a><h1 id="Docker容器内部署Java微服务的内存限制问题"><a href="#Docker容器内部署Java微服务的内存限制问题" class="headerlink" title="Docker容器内部署Java微服务的内存限制问题"></a>Docker容器内部署Java微服务的内存限制问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前两天有同事发现，通过华为云 ServiceStage 的流水线部署基于模板创建的 CSEJavaSDK demo 服务时，会在容器启动过程中报错。初步排查是由于 JVM 占用的内存超出了 docker 内存配额的上限，导致容器被 kill 掉。于是我们需要排查一下问题出在哪里，为什么以前没有这类问题，而现在却发生了。</p><h2 id="基本定位"><a href="#基本定位" class="headerlink" title="基本定位"></a>基本定位</h2><p>要确定 docker 容器内存超限问题的直接原因并不难。直接进入docker容器，执行 <code>top</code> 命令，我们发现宿主机是一台8核16G的机器，而且 docker 并不会屏蔽这些信息，也就是 JVM 会认为自己工作于一台 16G 内存的机器上。而查看 demo 服务的 Dockerfile，发现运行服务时并没有对 JVM 的内存进行任何限制，于是 JVM 会根据默认的设置来工作 —— 最大堆内存为物理内存的1/4(这里的描述并不完全准确，因为 JVM 的默认堆内存大小限制比例其实是根据物理内存有所变化的，具体内容请自行搜索资料)，而基于模板创建的 ServiceStage 流水线，在部署应用堆栈的时候会把 docker 容器的内存配额默认设置为 512M，于是容器就会在启动的时候内存超限了。至于以前没有碰到过这种问题的原因，只是因为以前没将这么高规格的 ECS 服务器用于流水线部署应用堆栈。</p><p>在查询过相关资料后，我们找到了两种问题解决方案，一个是直接在 jar 包运行命令里加上 <code>-Xmx</code> 参数来指定最大堆内存，不过这种方式只能将 JVM 堆内存限制为一个固定的值；另一个方法是在执行 jar 包时加上 <code>-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap</code> 参数，让 JVM 能够感知到docker容器所设置的 <code>cgroup</code> 限制，相应地调整自身的堆内存大小，不过这个特性是 JDK 8u131 以上的版本才具备的。</p><p>最终，我们提醒 ServiceStage 流水线的同学将 CSEJavaSDK demo 的创建模板做了改进，在 Dockerfile 中将打包的基础镜像版本由原先的 <code>java:8u111-jre-alpine</code> 升级为了 <code>openjdk:8u181-jdk-alpine</code>，并且在运行服务 jar 包的命令中加上了 <code>-Xmx256m</code> 参数。问题至此已经解决了。</p><h2 id="进一步的探究"><a href="#进一步的探究" class="headerlink" title="进一步的探究"></a>进一步的探究</h2><p>虽然问题已经解决，但是在好奇心的驱使下，我还是打算自己找个 demo 实际去触发一下问题，另外看看从网上搜到的解决方法到底好不好用 : )</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><p>创建云上工程</p><p><img src="/img/blog/MemoryConsumingOfJvmInDocker/create_cloud-base_project.PNG" srcset="/img/loading.gif" alt=""></p><p>首先需要在华为云 ServiceStage 创建一个云上工程。</p><p>在 ServiceStage -&gt; 应用开发 -&gt; 微服务开发 -&gt; 工程管理 -&gt; 创建云上工程中，选择“基于模板创建”，语言选择 Java， 框架选择 <code>CSE-Java (SpringMVC)</code>，部署系统选择“云容器引擎CCE”，给你的云上工程取一个名字，比如<code>test-memo-consuming</code>，最后选择存放代码的仓库，就可以完成云上工程的创建了。</p><p>之后云上工程会根据你的选项自动地生成脚手架代码，上传到你指定的代码仓库中，并且为你创建一条流水线，完成代码编译、构建、打包、归档镜像包的操作，并且使用打好的 docker 镜像包在 CCE 集群中部署一个应用堆栈。</p><blockquote><p>创建云上工程和流水线不是本文的重点，我就不详细讲操作了 : )。同一个应用堆栈的实例可以部署多个，在这里为了实验方便就按照默认值1个来部署。</p></blockquote><p><img src="/img/blog/MemoryConsumingOfJvmInDocker/demo_service_instance.PNG" srcset="/img/loading.gif" alt=""><br>由于云上工程已经改进了脚手架代码的模板，不会再出现内存超限的问题，所以我们现在能看到 demo 服务已经正常的跑起来，微服务实例已经注册到服务中心了。</p><p><img src="/img/blog/MemoryConsumingOfJvmInDocker/curl_helloworld.PNG" srcset="/img/loading.gif" alt=""><br>登录到 demo 服务所部署的容器，使用<code>curl</code>命令可以调用 demo 服务的 helloworld 接口，可以看到此时服务已经可以正常工作。</p></li><li><p>增加实验代码</p><p>为了能够触发微服务实例消耗更多的内存，我在项目代码中增加了如下接口，当调用<code>/allocateMemory</code>接口时，微服务实例会不停申请内存，直到 JVM 抛出 OOM 错误或者容器内存超限被 kill 掉。</p><pre><code class="java">private HashMap&lt;String, long[]&gt; cacheMap = new HashMap&lt;&gt;();@GetMapping(value = &quot;/allocateMemory&quot;)public String allocateMemory() { LOGGER.info(&quot;allocateMemory() is called&quot;); try {   for (long i = 0; true; ++i) {     cacheMap.put(&quot;key&quot; + i, new long[1024 * 1024]);   } } catch (Throwable t) {   LOGGER.info(&quot;allocateMemory() gets error&quot;, t); } return &quot;allocated&quot;;}</code></pre><p>此时用来打镜像包的基础镜像是<code>openjdk:8u181-jdk-alpine</code>，jar 包启动命令中加上了<code>-Xmx256m</code>参数。</p><p>执行流水线，应用堆栈部署成功后，调用<code>/allocateMemory</code>接口触发微服务实例消耗内存，直到 JVM 抛出 OOM 错误，可以在 ServiceStage -&gt; 应用上线 -&gt; 应用管理中选择相应的应用，点击进入概览页面，查看应用使用内存的情况。</p><p><img src="/img/blog/MemoryConsumingOfJvmInDocker/deploy_normal.PNG" srcset="/img/loading.gif" alt=""><br>应用使用的内存从 800M+ 陡然下降的时间点就是我重新打包部署的时间，而之后由于调用<code>/allocateMemory</code>接口，内存占用量上升到了接近 400M，并且在这个水平稳定了下来，显示<code>-Xmx256m</code>参数发挥了预期的作用。</p></li></ol><h3 id="复现问题"><a href="#复现问题" class="headerlink" title="复现问题"></a>复现问题</h3><p>现在将 demo 工程中的 Dockerfile 修改一下，将基础镜像改为 <code>java:8u111-jre-alpine</code>，并且删除启动命令中的<code>-Xmx256m</code>参数，将其提交为<code>noLimit_oldBase</code>分支，推送到代码仓库中。然后编辑流水线，将 source 阶段的任务所使用的代码分支改为<code>noLimit_oldBase</code>分支，保存并重新运行流水线，将新的代码打包部署到应用堆栈中。</p><div align=center><img src="/img/blog/MemoryConsumingOfJvmInDocker/deploy_noLimit_oldBase.PNG" srcset="/img/loading.gif" width="50%" height="50%"/></div>在微服务实例列表中查询到新的微服务实例的 endpoint IP 后，调用`/allocateMemory`接口，观察内存情况，内存从接近 400M 突然掉下去一下，然后又上升到约 450M 的时间点就是修改代码后的微服务实例部署成功的时间点，之后内存占用量突然下跌就是因为调用`/allocateMemory`接口导致容器内存超限被 kill 掉了。<p>如果你事先使用<code>docker logs -f</code>命令查看容器日志的话，那么日志大概是这个样子的</p><pre><code>2018-11-23 15:40:04,920  INFO SCBEngine:152 - receive MicroserviceInstanceRegisterTask event, check instance Id...2018-11-23 15:40:04,920  INFO SCBEngine:154 - instance registry succeeds for the first time, will send AFTER_REGISTRY event.2018-11-23 15:40:04,925  WARN VertxTLSBuilder:116 - keyStore [server.p12] file not exist, please check!2018-11-23 15:40:04,925  WARN VertxTLSBuilder:136 - trustStore [trust.jks] file not exist, please check!2018-11-23 15:40:04,928  INFO DataFactory:62 - Monitor data sender started. Configured data providers is {com.huawei.paas.cse.tcc.upload.TransactionMonitorDataProvider,com.huawei.paas.monitor.HealthMonitorDataProvider,}2018-11-23 15:40:04,929  INFO ServiceCenterTask:51 - read MicroserviceInstanceRegisterTask status is FINISHED2018-11-23 15:40:04,939  INFO TestmemoconsumingApplication:57 - Started TestmemoconsumingApplication in 34.81 seconds (JVM running for 38.752)2018-11-23 15:40:14,943  INFO AbstractServiceRegistry:258 - find instances[1] from service center success. service=default/CseMonitoring/latest, old revision=null, new revision=28475010.12018-11-23 15:40:14,943  INFO AbstractServiceRegistry:266 - service id=8b09a7085f4011e89f130255ac10470c, instance id=8b160d485f4011e89f130255ac10470c, endpoints=[rest://100.125.0.198:30109?sslEnabled=true]2018-11-23 15:40:34,937  INFO ServiceCenterTaskMonitor:39 - sc task interval changed from -1 to 302018-11-23 15:47:03,823  INFO SPIServiceUtils:76 - Found SPI service javax.ws.rs.core.Response$StatusType, count=0.2018-11-23 15:47:04,657  INFO TestmemoconsumingImpl:39 - allocateMemory() is calledKilled</code></pre><p>可以看到<code>allocateMemory</code>方法被调用，然后 JVM 还没来得及抛出 OOM 错误，整个容器就被 kill 掉了。</p><blockquote><p>这里也给大家提了一个醒：<strong>不要以为自己的服务容器能启动起来就万事大吉了</strong>，如果没有特定的限制，JVM 会在运行时继续申请堆内存，也有可能造成内存用量超过 docker 容器的配额！</p></blockquote><h3 id="让-JVM-感知cgroup限制"><a href="#让-JVM-感知cgroup限制" class="headerlink" title="让 JVM 感知cgroup限制"></a>让 JVM 感知<code>cgroup</code>限制</h3><p>前文提到还有另外一种方法解决 JVM 内存超限的问题，这种方法可以让 JVM 自动感知 docker 容器的 <code>cgroup</code> 限制，从而动态的调整堆内存大小，感觉挺不错的。我们也来试一下这种方法，看看效果如何 ; )</p><p>回到demo项目代码的<code>master</code>分支，将 Dockerfile 中启动命令参数的<code>-Xmx256m</code>替换为<code>-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap</code>，提交为<code>useCGroupMemoryLimitForHeap</code>分支，推送到代码仓库里。再次运行流水线进行构建部署。</p><div align=center><img src="/img/blog/MemoryConsumingOfJvmInDocker/deploy_useCGroupMemoryLimitForHeap.PNG" srcset="/img/loading.gif" width="50%" height="50%"/></div>等 demo 服务部署成功后，再次调用`/allocateMemory`接口，容器的内存占用情况如上图所示（最右边的那一部分连续曲线），内存上升到一定程度后，JVM 抛出了 OOM 错误，没有继续申请堆内存。看来这种方式也是有效果的。<p>不过，仔细观察容器的内存占用情况，可以发现容器所使用的内存仅为不到 300M，而我们对于这个容器的内存配额限制为 512M，也就是还有 200M+ 是闲置的，并不会被 JVM 利用。这个利用率，比起上文中直接设置<code>-Xmx256m</code>的内存利用率要低 : ( 。推测是因为 JVM 并不会感知到自己是部署在一个 docker 容器里的，所以它把当前的环境当成一个物理内存只有 512M 的物理机，按照比例来限制自己的最大堆内存，另一部分就被闲置了。</p><blockquote><p>如此看来，如果想要充分利用自己的服务器资源，还是得多花一点功夫，手动调整好<code>-Xmx</code>参数。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://royvanrijn.com/blog/2018/05/java-and-docker-memory-limits/" target="_blank" rel="noopener" title="Java and Docker, the limitations">Java and Docker, the limitations</a></li><li><a href="https://developers.redhat.com/blog/2017/03/14/java-inside-docker/" target="_blank" rel="noopener" title="Java inside docker: What you must know to not FAIL - RHD Blog">Java inside docker: What you must know to not FAIL</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>软件技术</category>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>microservice</tag>
      
      <tag>ServiceComb-Java-Chassis</tag>
      
      <tag>K8S</tag>
      
      <tag>docker</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源项目没有那么遥远</title>
    <link href="undefined2018/11/18/BecomingApacheServiceCombCommiter/"/>
    <url>2018/11/18/BecomingApacheServiceCombCommiter/</url>
    
    <content type="html"><![CDATA[<p>从小白到Apache项目Committer的成长之路。</p><a id="more"></a><h1 id="开源项目没有那么遥远"><a href="#开源项目没有那么遥远" class="headerlink" title="开源项目没有那么遥远"></a>开源项目没有那么遥远</h1><blockquote><p>前几天收到了Apache ServiceComb PMC的邀请邮件，这意味着我成为了一名Apache ServiceComb项目的Committer。喜悦之余，我想留下一篇博客作为自己工作的一个阶段性总结，同时也希望这篇文章能够给其他想要加入到开源社区的同学一点参考。</p></blockquote><h2 id="初次接触ServiceComb"><a href="#初次接触ServiceComb" class="headerlink" title="初次接触ServiceComb"></a>初次接触ServiceComb</h2><p>最开始接触到“开源”的概念是在大学的计算机课程上，当时对于开源项目的印象就是：开源项目是由一群大牛程序员开发和维护的，作为小白的我只需要拿来用就好了。</p><p>毕业之后参加工作，我被分到了一个跟开源项目相关的工作组，需要向<a href="https://servicecomb.apache.org/cn/" target="_blank" rel="noopener" title="ServiceComb官网">Apache ServiceComb项目</a>提交代码。当时的心情真是既新奇又紧张，毕竟以前只是单纯地使用过开源软件，而现在自己终于要向开源软件项目提交代码了。这种能够在一个开源项目中提交自己代码的兴奋感，相信很多学软件专业的同学应该能够理解。但是自己又是刚开始工作的小白，担心自己写的代码太差了拿不出手，因此又紧张不已。而事实上我第一次提交代码的经过并没有预想中的那么多波折，作为一个开源小白，提上去的pull request有瑕疵是很正常的事情，根据检视者的意见修改好了就行——毕竟高手不一定高冷，社区的开发者们都是很热心的。</p><p>有了第一次提交PR的经历后，后面的工作就慢慢变得轻车熟路了。平常我在开源社区主要做的就是领一些新特性或者修复bug的<a href="https://issues.apache.org/jira/projects/SCB/issues" target="_blank" rel="noopener" title="Apache issues">issue</a>处理，提交代码或文档的修改。</p><h2 id="参与的方式不仅仅是写代码……"><a href="#参与的方式不仅仅是写代码……" class="headerlink" title="参与的方式不仅仅是写代码……"></a>参与的方式不仅仅是写代码……</h2><p>如前文所提到的，最初我参与Apache ServiceComb开源项目的内容是由工作驱动的。因为有一些新特性要完成，或者因为有一些bug要修复，所以我需要提交代码和更新相关文档。而在代码和文档之外的其他事务我并没有参与多少。</p><p>其实从我开始向ServiceComb提交代码时，我就订阅了<a href="https://servicecomb.apache.org/cn/developers/subscribe-mail-list/" target="_blank" rel="noopener" title="订阅邮件">Apache ServiceComb的邮件列表</a>，也加入了<a href="https://servicecomb.apache.org/cn/developers/use-gitter/" target="_blank" rel="noopener" title="使用Gitter">Gitter聊天室</a>。不过由于对自己的技术没什么自信，也受限于内向的性格，我在这些沟通渠道内长期保持着旁观的状态。当时的想法是，讨论ServiceComb设计和发展的事情我又参与不了，看看大佬们讨论就可以，到时候我再捞几个issue来做就好了。然而这种想法是不对的，对于我们自身在开源社区中的发展也没有好处。要参与开源社区的事务，仅仅只是埋头提交代码是不够的，积极参与社区的讨论、沟通，保持自己在社区中的活跃度，也是评判自己在社区工作好坏的一项标准。这也符合Apache之道中“社区胜于代码”的理念。此外，把将要进行的事情放到邮件中讨论，也是一个文档归档的过程。后续想要回溯某个特性为什么会被加进来，或者某个bug是如何触发的时候，搜索相关的邮件就可以了。如果有新的贡献者想要参与到社区开发工作中来，他们也可以通过查阅邮件来了解很多信息。这在无形中节省了很多后续的维护和沟通成本。</p><p>参与社区讨论的活跃程度也是评判一个开发者能否成为committer的重要标准。听先前已经进入ServiceComb社区的同事说，其实按照我的代码提交量来看，在之前我就可以成为committer了，然而由于我在社区沟通中的活跃度实在是太低了，所以才一直没有受到ServiceComb PMC的committer邀请……所以说，同学们一定不要被自己的腼腆性格坑了啊，要参与社区事务，就需要更积极地加入到讨论中来。</p><h2 id="给有意者的一些建议"><a href="#给有意者的一些建议" class="headerlink" title="给有意者的一些建议"></a>给有意者的一些建议</h2><p>参与一个开源项目，对于自己阅读文档、分析源码、开发和沟通的能力都有很大的益处。这和开发一个业务系统是两种完全不同的体验，对于拓展个人的视野和经验很有帮助，我想大家应该从各种文章里了解很多了，我在这里就不多讲了 : )</p><p>如果想要参与到一个开源项目中，可以首先了解一下如何使用这个项目。给开源社区做贡献的方式不仅仅限于提交代码，<a href="https://github.com/apache/servicecomb-docs" target="_blank" rel="noopener" title="ServiceComb文档项目">修复文档问题</a>可能是一个更好的切入点。通过阅读和修复文档问题，我们可以了解到一个项目的主要特性，这对于我们进一步了解项目源码也是很有帮助的。</p><p>同时，<a href="https://servicecomb.apache.org/cn/developers/subscribe-mail-list/" target="_blank" rel="noopener" title="订阅邮件">订阅邮件列表</a>和<a href="https://servicecomb.apache.org/cn/developers/use-gitter/" target="_blank" rel="noopener" title="使用Gitter">使用Gitter</a>也很有必要。通过这些，我们不仅可以了解到项目的最新动态，也能够参与到社区的讨论中来。如果还不了解如何发起一场讨论的话，可以先看看社区里的开发者是怎么做的，参与到其他人的邮件讨论中去。碰到其他的使用者提问也可以上去帮助解答，这同样是一种参与贡献的方式。上文已经提到过了，参与讨论沟通是社区活动的重要内容。不用感到不好意思，开源社区本身就是开放的，我们欢迎更多的人能够参与到项目的建设中来。</p><p>正所谓临渊羡鱼，不如退而结网。与其羡慕已经成功参与到开源项目中的同学，不如从现在开始行动，选择一个开源项目参与进去 ; )</p><p>文章的最后，我想向给与我帮助和鼓励的社区团队成员致以感谢，谢谢大家热心的帮助和指导，让我从一名小白成长为Apache committer。</p><blockquote><p>ps：在这里小小地安利一下，<a href="https://servicecomb.apache.org/cn/" target="_blank" rel="noopener" title="ServiceComb官网">Apache ServiceComb项目</a>已经从Apache孵化器毕业，正式成为Apache顶级项目，这也是业界首个微服务项目在Apache孵化并毕业成为顶级项目。ServiceComb中包含的几个子项目都处于如火如荼的发展势头中，欢迎大家参与到ServiceComb社区建设中来~</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>职业发展</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ServiceComb</tag>
      
      <tag>开源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【ServiceComb】微服务调用，应答返回时报ClassCastException问题的定位</title>
    <link href="undefined2018/08/09/DecodeResponseErrorProblemLocation/"/>
    <url>2018/08/09/DecodeResponseErrorProblemLocation/</url>
    
    <content type="html"><![CDATA[<p>记录一个返回值反序列化及类型转换的问题。</p><a id="more"></a><h1 id="【ServiceComb】微服务调用，应答返回时报ClassCastException问题的定位"><a href="#【ServiceComb】微服务调用，应答返回时报ClassCastException问题的定位" class="headerlink" title="【ServiceComb】微服务调用，应答返回时报ClassCastException问题的定位"></a>【ServiceComb】微服务调用，应答返回时报ClassCastException问题的定位</h1><blockquote><p>本文基于CSEJavaSDK-2.3.35版本进行描述，对应的ServiceComb-Java-Chassis版本是1.1.0.B006。<br>文中的示例业务日志和代码来自<a href="https://github.com/yhs0092/CSEBlogDemo-DecodeResponseError" target="_blank" rel="noopener">问题复现demo</a>。</p></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>问题复现demo在<a href="https://github.com/yhs0092/CSEBlogDemo-DecodeResponseError" target="_blank" rel="noopener">这里</a>。</p><p>前几天被拉去看一个问题。某服务（后面称其为A服务）采用同步模式运行，RPC方式调用其他微服务。在本地调试无问题，线上运行时此服务调用另外一个服务（后面称其为B服务）的接口会报错，且通过他们自定义扩展的一个<code>HttpClientFilter</code>的日志来看，被调用的provider服务已经正常返回了应答消息，但是在后面会报<code>ClassCastException</code>，无法将<code>InvocationException</code>转型为业务代码的返回值类型。日志如下：</p><pre><code>// 业务逻辑被调用[INFO] test() is called! com.github.yhs0092.blogdemo.javachassis.service.ConsumerService.test(ConsumerService.java:20)// 用户自定义的HttpClientFilter中打印了provider返回的消息[INFO] get response, status[200], content is [{&quot;content&quot;:&quot;returnOK&quot;}] com.github.yhs0092.blogdemo.javachassis.filter.PrintResponseFilter.afterReceiveResponse(PrintResponseFilter.java:26)// ClassCastException被抛出[ERROR] invoke failed, invocation=PRODUCER rest client.consumer.test org.apache.servicecomb.swagger.invocation.exception.DefaultExceptionToResponseConverter.convert(DefaultExceptionToResponseConverter.java:35)java.lang.ClassCastException: org.apache.servicecomb.swagger.invocation.exception.InvocationException cannot be cast to com.github.yhs0092.blogdemo.javachassis.service.TestResponse    at com.sun.proxy.$Proxy30.test(Unknown Source)    at com.github.yhs0092.blogdemo.javachassis.service.ConsumerService.test(ConsumerService.java:21)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke(Method.java:498)    at org.apache.servicecomb.swagger.engine.SwaggerProducerOperation.doInvoke(SwaggerProducerOperation.java:160)    at org.apache.servicecomb.swagger.engine.SwaggerProducerOperation.syncInvoke(SwaggerProducerOperation.java:148)    at org.apache.servicecomb.swagger.engine.SwaggerProducerOperation.invoke(SwaggerProducerOperation.java:115)    at org.apache.servicecomb.core.handler.impl.ProducerOperationHandler.handle(ProducerOperationHandler.java:40)</code></pre><p>分析问题的过程中，他们提到由于线上的B服务还是旧版本的没有升级，于是他们把A服务依赖的B服务的接口jar包替换成了低版本来启动的。</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>初步接触这个问题给人一种很怪异的感觉。如果一个consumer调用provider时都已经拿到了应答，那么会直接把应答返回给consumer的业务逻辑代码；万一中间真的出错了，那产生的<code>InvocationException</code>也应该是被“抛”出去的，而不是像日志里面显示的那样，尝试“返回”给consumer的业务逻辑才对。</p><p>可供分析的信息太少了，只能回头看一下sdk代码的相关逻辑，看看能不能复现出这个问题。</p><p>RPC调用模式的微服务里，业务逻辑通过provider接口做调用时，实际是通过ServiceComb生成的provider接口类型的代理来做调用的。而在这个代理的背后，实际调用流程的源头在<code>org.apache.servicecomb.provider.pojo.Invoker</code>类里面。同步调用模式下，区分应答如何被返回给业务逻辑的关键代码在<code>syncInvoke</code>方法里：</p><pre><code class="java">protected Object syncInvoke(Invocation invocation, SwaggerConsumerOperation consumerOperation) {  Response response = InvokerUtils.innerSyncInvoke(invocation);  if (response.isSuccessed()) {    // 在这里，response内的result会作为正常应答返回给业务逻辑    return consumerOperation.getResponseMapper().mapResponse(response);  }  // 这里是异常逻辑，response内的result即为错误信息，会被包装为InvocationException抛给业务逻辑  throw ExceptionFactory.convertConsumerException(response.getResult());}</code></pre><p>出现了线上日志中的错误说明这个方法没有走到throw语句，而是走return语句那里返回了。</p><p><code>InvokerUtils.innerSyncInvoke()</code>方法里触发的主要流程是Handler-&gt;HttpClientFilter-&gt;网络线程，既然在用户自定义的<code>HTTPClientFilter</code>实现类的<code>afterReceiveResponse()</code>方法中已经打印出了B服务返回的应答消息，那么网络线程部分的嫌疑就可以排除了。问题只可能出在<code>Invoker</code>、<code>Handler</code>、<code>HTTPClientFilter</code>这三块。这个异常需要被catch住并塞到<code>response</code>里。同时，为了让异常作为response body返回，而不是被“抛”出去，<code>response.isSuccessed()</code>需要返回<code>true</code>，这就要求<code>response</code>的Http状态码必须是2xx的。通过在demo中加入自定义的<code>HttpClientFilter</code>，在<code>afterReceiveResponse()</code>方法中抛出一个状态码为200的<code>InvocationException</code>，我们复现出了这个问题，其日志特征与A服务的线上日志一致。</p><h2 id="根因确定"><a href="#根因确定" class="headerlink" title="根因确定"></a>根因确定</h2><p>一个response，里面装着一个异常，Http状态码却是2xx的，这个场景应该是不会发生的才对。在向A服务的开发同学确认了他们没有在自定义的<code>Handler</code>、<code>HttpClientFilter</code>内直接操作response后，我们通过日志也无法给出问题结论，只能等A服务的开发同学本地复现问题场景了。</p><p>好在这个问题本地是能够复现出来的，根因是在于A服务依赖的B服务接口jar包被替换后，旧版本的业务接口应答类型比新版本的多一个属性，而且这个属性的类型是找不到的，大致像下面这样：</p><pre><code class="java">class ResponseType {  private InnerFieldType someField; // 这里的InnerFieldType会报ClassNotFound}</code></pre><p>于是当<code>DefaultHttpClientFilter</code>的<code>extractResult()</code>方法尝试将Http body中的json串反序列化为业务代码中的应答对象时，会抛出一个异常，而这个异常被包装成<code>InvocationException</code>后，是被“return”回去的，而不是“throw”出去的，并且这个过程中没有打印任何日志。关键代码在<code>DefaultHttpClientFilter</code>的85-89行：</p><pre><code class="java">try {  return produceProcessor.decodeResponse(responseEx.getBodyBuffer(), responseMeta.getJavaType());} catch (Exception e) {  return ExceptionFactory.createConsumerException(e); // 异常被返回}</code></pre><p>“return”回去的异常被作为正常的应答对象塞进了<code>response</code>中，而<code>response</code>的状态码是Http应答的状态码——200，于是就有了线上碰到的错误。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ServiceComb框架在此次定位过程中暴露出来的缺少日志的问题会在后续版本中修复。但是对于开发者而言，更重要的是服务上线部署前需要做好充分验证，临时替换依赖jar包这种简单粗暴的处理方式不可取。</p><p>那么本地调试过程中碰到这种问题应该如何定位呢？以本文所描述的场景（RPC调用方式，同步运行模式）来看，当业务代码中触发一次微服务调用，ServiceComb的处理流程大致是：</p><blockquote><p>Invoker -&gt; InvokerUtils -&gt; Handler -&gt; HTTPClientFilter -&gt; 网络线程</p></blockquote><p><code>Invoker</code>是RPC调用模式下的动态代理，业务代码通过provider接口做调用时，参数首先被传到<code>invoke()</code>方法中。由于consumer工作于同步模式，<code>Invoker</code>会通过<code>syncInvoke()</code>方法调用<code>InvokerUtils</code>的<code>innerSyncInvoke()</code>方法。在这里，<code>Invocation</code>的<code>next()</code>方法被调用，<strong><em>从而触发Handler链执行</em></strong>。在Handler链的末尾是<code>TransportClientHandler</code>，它会调用对应的transport方式发送请求。在Rest over Vertx传输方式下，我们需要关注的是<code>RestClientInvocation</code>的<code>invoke()</code>方法，这里会<strong><em>遍历执行HttpClientFilter的beforeSendRequest()方法</em></strong>，然后将请求调度到网络线程中发送。业务线程此时处于等待返回的状态（<code>SyncResponseExecutor.waitResponse()</code>方法中使用<code>CountDownLatch</code>进行等待）。</p><p>当请求应答返回后，<code>RestClientInvocation.processResponseBody()</code>方法会将Http response body返回给业务线程处理（通过触发<code>SyncResponseExecutor</code>的<code>CountDownLatch</code>）。应答首先会在<code>RestClientInvocation</code>中<strong><em>遍历HttpClientFilter的afterReceiveResponse()方法</em></strong>进行处理，然后<strong><em>经过Handler链</em></strong>的回调处理，最终返回给<code>InvokerUtils</code>的<code>syncInvoke()</code>方法。其中，<strong><em>Http response body是在DefaultHttpClientFilter的extractResult()方法中反序列化为业务接口返回对象的</em></strong>。这个方法会根据<code>response</code>的HTTP状态码判断如何对待结果，如果是2xx的状态码，则<code>response</code>中的<code>result</code>会作为正常的应答返回给业务逻辑，否则会将<code>result</code>包装到<code>InvocationException</code>中抛给业务逻辑。</p><pre><code class="java">  // RestClientInvocation中处理应答的关键方法  protected void processResponseBody(Buffer responseBuf) {    invocation.getResponseExecutor().execute(() -&gt; {      // 同步模式下，应答返回流程从这里开始就是在业务线程里执行的      try {        HttpServletResponseEx responseEx =            new VertxClientResponseToHttpServletResponse(clientResponse, responseBuf);        for (HttpClientFilter filter : httpClientFilters) {          // HttpClientFilter处理返回消息体，普通的filter会返回null          Response response = filter.afterReceiveResponse(invocation, responseEx);          if (response != null) { // DefaultHttpClientFilter会把消息体反序列化为应答对象，装入response返回            asyncResp.complete(response); // 通过回调触发handler链            return;          }        }      } catch (Throwable e) {        asyncResp.fail(invocation.getInvocationType(), e); // 包装异常，通过回调触发handler链      }    });  }</code></pre><p>本地分析这类问题的时候，首先需要知道请求发送的流程，了解RPC动态代理的入口、<code>Handler</code>链的起止点、<code>HttpClientFilter</code>的调用点。这些是流程中的关键节点，根据这些信息可以大致确定问题出现的范围。至于更进一步的定位，就需要大家根据具体的问题进行分析了。</p><blockquote><p>看不懂上面说的是什么？正常 :P</p><p>只看一篇博客是很难弄懂这段流程的。关键的代码节点已经给出来了，自己写个demo调试一下，你的了解会更深刻</p><p>(￣▽￣)ﾉ</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>软件技术</category>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>microservice</tag>
      
      <tag>ServiceComb-Java-Chassis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【华为云微服务引擎】从代码机制看AK/SK认证问题</title>
    <link href="undefined2018/08/02/AKSKAuthenticationProblemLocation/"/>
    <url>2018/08/02/AKSKAuthenticationProblemLocation/</url>
    
    <content type="html"><![CDATA[<p>排查AK/SK认证问题的常见路径和底层代码分析。</p><a id="more"></a><h1 id="【华为云微服务引擎】从代码机制看AK-SK认证问题"><a href="#【华为云微服务引擎】从代码机制看AK-SK认证问题" class="headerlink" title="【华为云微服务引擎】从代码机制看AK/SK认证问题"></a>【华为云微服务引擎】从代码机制看AK/SK认证问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用户开发的微服务要想注册到CSE的服务中心，就需要用到AK/SK认证。由于CSEJavaSDK提供了较多的配置方式，有时候容易出现错配和漏配的情况，本文从CSEJavaSDK读取AK/SK的关键代码入手进行分析，希望能够给大家提供一点AK/SK认证失败时的定位思路。（本文基于CSEJavaSDK-2.3.30进行说明）</p><h2 id="代码逻辑分析"><a href="#代码逻辑分析" class="headerlink" title="代码逻辑分析"></a>代码逻辑分析</h2><p>首先需要说明的是，AK/SK也是一个配置项，因此它可以配置在microservice.yaml文件里，可以通过-D设置系统属性来指定，也可以通过环境变量来指定（Windows的环境变量貌似可以带点号<code>.</code>，因此你可以直接在环境变量中指定cse.credentials.accessKey=ak；而Linux的环境变量不能带点，所以不能这么做）。另一方面来说，AK/SK又是一个比较特殊的配置项，因此CSEJavaSDK又提供了一个<a href="https://support.huaweicloud.com/devg-cse/cse_03_0088.html" target="_blank" rel="noopener">加密存储</a>的配置方式。无论AK/SK的来源是哪里，最终CSEJavaSDK都是在AKSKManager中完成AK/SK的读取逻辑的。</p><pre><code class="java">public static Credentials getCredential() throws Exception {  // 读取AK/SK  AKSKOption option = AKSKOption.readAKSK();  // 中间读写缓存等等逻辑忽略……  // 根据cse.credentials.akskCustomCipher配置获取cipher，对AK/SK进行解密    AKSKCipher cipher = (AKSKCipher)CIPHERS.get(option.getAkskCustomCipher());  // 检查逻辑忽略...    char[] ak = cipher.decode(TYPE.AK, option.getAccessKey().toCharArray());    char[] sk = cipher.decode(TYPE.SK, option.getSecretKey().toCharArray());    String project = option.getProject();    if (project == null || project.isEmpty()) {      // 如果用户没有配置cse.credentials.project，就尝试从配置的服务中心地址进行解析，具体的代码忽略……      // 我们平常通过APIGateway连接到服务中心，例如你要连到华北区，配置的地址就是这样的 https://cse.cn-north-1.myhuaweicloud.com      // 可以从中截取出 cn-north-1，这个就是华北区的project      LOGGER.info(&quot;The application missing project infomation, so choose a nearest one [{}]&quot;, project);    }  return credentials;}</code></pre><p>以上是AKSKManager的getCredential方法逻辑，可以看到大体的流程是读取AK/SK、根据cse.credentials.akskCustomCipher配置项获取cipher对aksk进行解密、获取cse.credentials.project配置信息。此方法返回的credentials内包含了明文的AK/SK、project信息，因此<strong><em>本地调试时确定AK/SK读取是否有问题的最快途径就是在getCredential方法末尾打断点，查看credentials包含的信息</em></strong>。</p><p>而在AKSKOption.readAKSK()中读取AK/SK的关键流程如下：</p><pre><code class="java">public static AKSKOption readAKSK() {  // 从AK/SK加密存储文件读取  AKSKOption option = readFromFile();  if (option == null) {    // 从配置中读取，注意：环境变量、System Property、配置文件都算在这里面    option = buildFromYaml();  }  return option;}private static AKSKOption readFromFile() {  // 忽略缓存逻辑……  // 先尝试从环境变量CIPHER_ROOT中读取加密存储文件的目录    String cipherPath = System.getenv(&quot;CIPHER_ROOT&quot;);    if (cipherPath == null || cipherPath.isEmpty()) {      // 若不存在则从/opt/CSE/etc/cipher目录中读取      cipherPath = &quot;/opt/CSE/etc/cipher&quot;;    }    String certFilePath = cipherPath + File.separator + &quot;certificate.yaml&quot;;    File certFile = new File(certFilePath);    if (!certFile.exists() || certFile.isDirectory()) {      // 文件不存在时尝试从系统属性user.dir配置的目录中读取      certFile = new File(System.getProperty(&quot;user.dir&quot;) + File.separator + &quot;certificate.yaml&quot;);      if (!certFile.exists() || certFile.isDirectory()) {        return null;      }    }    AKSKOption option = readFromFile(certFile);    return option;}</code></pre><p>可以看到CSEJavaSDK优先读取加密存储的AK/SK文件，读不到才去配置中找。而AK/SK加密文件的读取路径优先级从高到低分别是CIPHER_ROOT环境变量配置的目录、/opt/CSE/etc/cipher目录、user.dir系统属性配置的目录（这个少见）。</p><h2 id="常见问题分析思路"><a href="#常见问题分析思路" class="headerlink" title="常见问题分析思路"></a>常见问题分析思路</h2><p>当发生AK/SK认证失败的问题时，我们首先需要对问题有个基本的定界，即问题是出在AK/SK读取（解密）上，还是出在AK/SK的内容本身。</p><p>如果是本地开发调试，那么这个问题很好确定，直接在<code>AKSKManager</code>的<code>getCredential</code>方法里打断点去看一下即可。如果是在线上部署运行的服务，那么只能看日志，凭经验来定位了。与AK/SK认证相关的日志关键词有这些：</p><ul><li>“read ak/sk from”：显示AK/SK的来源是哪里，”read ak/sk from security storage file.”表示服务实例从AK/SK加密存储文件中读取配置项的，”read ak/sk from microservice.yaml.”表示服务实例从配置项中读物AK/SK的（注意，这里说的是<strong><em>配置项，包含了环境变量、系统属性以及配置文件</em></strong>，不单单是指microservice.yaml文件）。</li><li>“add ak/sk cipher”：加载<code>AKSKCipher</code>，cipher用于解密SK。CSEJavaSDK默认提供的cipher有default、security，default用于明文存储AK/SK的场景，security在<a href="https://support.huaweicloud.com/devg-cse/cse_03_0088.html" target="_blank" rel="noopener">AK/SK加密存储</a>场景中使用。CSEJavaSDK使用SPI机制加载cipher，如果发现日志中没有打印加载default和security的内容，那么你就需要检查一下自己依赖的jar包了。</li><li>“sign request failed …… OSS_ROOT not properly set”：当cipher为<code>security</code>时，CSEJavaSDK会去CIPHER_ROOT环境变量配置的目录里读取解密密钥文件common_shared.key和root.key，如果用户忘记配置CIPHER_ROOT了，就会打印这个错误。</li><li>“Cipher decode error, will use original as plain!”：SK解密失败时会打印此错误日志，常见的错误原因包括CIPHER_ROOT环境变量下没有密钥文件、程序没有权限读取密钥文件、Java没有开启高强度加密功能等。关于Java高强度加密功能，大家去网上搜一下JCE policy能找到解除限制的方法，较低版本的jdk8需要下载一个jce的jar包，高版本的直接修改jre目录下的lib/security/java.security文件配置即可，这个限制只存在于Oracle JDK中，OpenJDK没有此限制。</li><li>AK/SK或project配置内容错误：当内容配置出错时，实际上AK/SK的读取加密过程并不会报错，只有等到CSEJavaSDK向CSE后端服务（sc/cc/monitor）发送请求时，才会拿到错误返回消息，错误信息包括如下类型：<pre><code>AK内容错误：401:Unauthorized, {&quot;errorCode&quot;:&quot;401002&quot;,&quot;errorMessage&quot;:&quot;Request unauthorized&quot;,&quot;detail&quot;:&quot;Get service token from iam proxy failed,{\&quot;error\&quot;:\&quot;get SK from AK from iam failed. error:Object Not Found - details: \&quot;}&quot;}</code></pre><pre><code>SK内容错误：401:Unauthorized, {&quot;errorCode&quot;:&quot;401002&quot;,&quot;errorMessage&quot;:&quot;Request unauthorized&quot;,&quot;detail&quot;:&quot;Get service token from iam proxy failed,{\&quot;error\&quot;:\&quot;validate ak sk error\&quot;}&quot;}</code></pre><pre><code>project配置错误：401:Unauthorized, {&quot;errorCode&quot;:&quot;401002&quot;,&quot;errorMessage&quot;:&quot;Request unauthorized&quot;,&quot;detail&quot;:&quot;Get service token from iam proxy failed,{\&quot;error\&quot;:\&quot;get project token from iam failed. error:http post failed, statuscode: 400\&quot;}&quot;}</code></pre>这些错误内容都是华为云服务的认证鉴权机制返回的，后期如果相关服务升级的话，也许返回的错误内容会有变化。但总之大家可以抓住关键的一点，就是如果前面的AK/SK加载过程都没有报错，只有连接CSE后端服务时拿到401的错误返回，那么你就需要检查一下自己的AK/SK、project是否配置对了。-D启动参数、环境变量、各个microservice.yaml文件都是需要排查的。至于project的配置，可以参考<a href="https://support.huaweicloud.com/usermanual-iam/zh-cn_topic_0079477316.html" target="_blank" rel="noopener">如何查看项目ID</a>。project和你所连接的region是相关的，比如华北区连接的APIGateway地址就是<a href="https://cse.cn-north-1.myhuaweicloud.com" target="_blank" rel="noopener">https://cse.cn-north-1.myhuaweicloud.com</a> ，project应该配置为cn-north-1。如果你不配置，CSEJavaSDK会尝试从sc地址中截取出来，但不一定能拿到正确的值，此时启动日志里面会打印提示信息，例如”The application missing project infomation, so choose a nearest one [cn-north-1]”，就是在告诉你自动选取的project是cn-north-1。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>博主对AK/SK认证的了解大致也就是上面这些了，很多内容也只能提供一点参考和启发意义。项目实际运行的情况复杂多样，当大家遇到相关问题的时候还是需要根据上面提到的代码逻辑，结合自己服务的实际运行环境去分析，才能更好地定位问题。</p>]]></content>
    
    
    <categories>
      
      <category>软件技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ServiceComb</tag>
      
      <tag>CSE</tag>
      
      <tag>华为云</tag>
      
      <tag>microservice</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>